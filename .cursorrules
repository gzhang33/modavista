@always
# Version: 2.3
# Purpose: Guide AI for development on this project.

## 1. CORE DIRECTIVES
- **Project Goal**: B2B product showcase (non-ecommerce).
- **Primary User**: Clients browsing products.
- **Secondary User**: Admin maintaining the catalog.
- **Technology Stack**: Vanilla JS (ES6+, modules, class-based), PHP 7+, MySQL. 
- **Architecture Principles**: Componentized, modular, single-responsibility, and clear separation of concerns.
- **Variants Model**: Each color variant is an independent `products` row sharing base attributes; admin tools support batch creation.

## 2. TECHNICAL SPECIFICATIONS

### 2.1. Backend (PHP)
- **Scope**: All server-side logic resides under the `api/` directory, exposing RESTful JSON endpoints.
- **Database Interaction**: Use `mysqli` prepared statements for all queries. Prohibit SQL string concatenation.
- **Responses**: All endpoints must return JSON with a consistent schema for success and errors.
- **Authentication**: Admin-only endpoints require authenticated sessions; public, read-only catalog endpoints are accessible without auth.
- **Security & Configuration**: Store secrets/configuration only within backend configuration; hash admin credentials using strong one-way algorithms (bcrypt or equivalent).
- **Variants Creation (Batch)**: When receiving variant metadata with associated media, create one product per variant and suffix the name with the color.

### 2.2. Frontend (JavaScript)
- **Modular Architecture**: Use ES6 modules and classes. Keep components single-purpose and reusable.
- **Communication Pattern**: Use an event bus (pub/sub) for decoupled inter-component communication.
- **HTTP Layer**: Centralize API requests in a thin client utility with basic error normalization.
- **Public Site**: UI is composed from modular components and utilities orchestrated by lightweight entry scripts.
- **Admin Panel**: Uses the same modular approach with an event bus and a component manager to coordinate feature-specific components.
- **Styling**: Use CSS custom properties and BEM for maintainable theming.
- **Libraries**: Prefer no external libraries. If absolutely needed for complex UI, document them in the README under “Libraries Used”.

### 2.3. Database (MySQL)
- **Primary Key**: `products.id` MUST be a string with the format `prod_[uniqid]`.
- **Media Storage**: `products.media` field is a JSON array of image file paths.
- **Default Image**: `products.defaultImage` is the first path from the `media` array.
 - **Variants**: `products.variants` (JSON/LONGTEXT) may store `{ color: "Red" }` for variant metadata. No separate parent/child tables.

### 2.4. Project File Structure
- `/`: Public-facing documents and entry points for the site.
- `/api/`: Server-side PHP endpoints and backend utilities.
- `/assets/`: Public site assets (JavaScript modules, utilities, components, styles, and shared libraries).
- `/assets/js/components/`: Reusable, single-responsibility UI components for the public site.
- `/assets/js/utils/`: Shared client-side utilities (API client, helpers).
- `/admin/`: Admin-facing pages, assets, and components for catalog management.
- `/admin/assets/js/components/`: Reusable, modular admin UI components.
- `/images/`: Uploaded media files managed by the backend.

## 3. DEVELOPMENT WORKFLOWS

### 3.1. Create Resource (Generic)
1. Client component submits a POST request (form or JSON) to a backend endpoint.
2. Backend authenticates (if required), validates payload, and processes files (if any).
3. Backend persists data using prepared statements and stores media paths when uploads are present.
4. Backend responds with a normalized JSON object indicating success or error.

### 3.2. Read/Update/Delete Resource (Generic)
- **Read**: Public endpoints support listing and single-resource retrieval with optional filtering.
- **Update/Delete**: Admin endpoints require authentication and validate input before mutating state.
- **Derived Data**: Aggregated or derived collections should be computed on demand rather than stored redundantly.

## 4. CODE STYLE & STANDARDS
- **PHP**: Follow PSR-12. Keep functions small and single-purpose. Use clear naming and avoid magic values.
- **JavaScript**: ES6+ modules and classes, `async/await`, explicit exports/imports. Encapsulate internals; expose minimal public APIs. Document with concise JSDoc.
- **CSS/HTML**: Semantic HTML5; use BEM and CSS variables for theming.
- **Naming & Consistency**: Maintain consistent naming conventions and directory structure across public and admin code.

## 5. PUBLIC SITE ARCHITECTURE
- Build UI from modular components (`assets/js/components/`) coordinated by lightweight entry scripts.
- Data flows through a centralized API utility; components react to data and events.
- Favor event-driven interactions and avoid tight coupling between components.

## 6. ADMIN PANEL ARCHITECTURE
- Use an event bus for cross-component communication and a component manager to control lifecycle.
- Components are isolated, testable modules that handle specific admin features (tables, forms, modals, etc.).
- Follow the same module, utility, and styling conventions as the public site.

## 7. TESTING & QUALITY ASSURANCE
- Prefer external end-to-end testing tools/services; do not store test specs within this repository.
- Ensure environment validation precedes automated tests (server, database, permissions).
- Every feature or change should be covered by unit and end-to-end tests managed externally.
- Keep the application focused on runtime code; testing configuration is minimal and externalized.

## 8. COMMON PRINCIPLES FOR DEBUGGING
- Verify module import paths, avoid circular dependencies, and ensure assets are served over HTTP(S).
- Confirm DOM availability before component initialization; attach listeners after elements exist.
- Normalize API errors; ensure all endpoints return JSON with meaningful status and messages.
- Check database connectivity and credentials when server errors occur; validate file permissions for uploads.

## 9. MAINTENANCE POLICY
- On structural or feature changes, update both `README.md` and `.cursorrules` to reflect architecture, workflows, and constraints.
- Continuously refactor to reduce duplication, improve naming, and keep modules single-responsibility.
